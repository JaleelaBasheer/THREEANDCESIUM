import React, { useState, useEffect, useRef } from 'react';
import { DebugTilesRenderer as TilesRenderer, NONE, TilesGroup } from '3d-tiles-renderer';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
import { GUI } from 'three/examples/jsm/libs/lil-gui.module.min.js';
import { CesiumIonTilesRenderer } from '3d-tiles-renderer';

function NewComponent() {
  let camera, controls, scene, renderer, tiles, light, offsetParent, raycaster, mouse;
  let selectedObject = null;

  const canvasRef = useRef(null);
  const [highlightColor, setHighlightColor] = useState('#ff0000');
  const [contextMenuPosition, setContextMenuPosition] = useState({ x: 0, y: 0 });
  const [contextMenuColor, setContextMenuColor] = useState(highlightColor);
  const [assetList, setAssetList] = useState([]);


  const params = {
    'raycast': NONE,
    'ionAssetId': '2418669',
    'ionAccessToken': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIwZWU3MTJjNi00Njk1LTQxZDktYmE4OS1mY2I3NTIyYzVhZTgiLCJpZCI6MTg3NjI0LCJpYXQiOjE3MDQ1NjAzMzF9.5FAkHltPwh5gROFmAfIEalS68ob5Xnsjt7EMkNcyIjE',
    'reload': () => {
      reinstantiateTiles();
    }
  };
  const ionAssetId = '2418669'
  const ionAccessToken='eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIwZWU3MTJjNi00Njk1LTQxZDktYmE4OS1mY2I3NTIyYzVhZTgiLCJpZCI6MTg3NjI0LCJpYXQiOjE3MDQ1NjAzMzF9.5FAkHltPwh5gROFmAfIEalS68ob5Xnsjt7EMkNcyIjE'
  useEffect(() => {
     const fetchAssetDetails = async () => {
      try {
        const response = await fetch(`https://api.cesium.com/v1/assets`, {
          headers: {
            Authorization: `Bearer ${ionAccessToken}`,
          },
        });

        if (response.ok) {
          const data = await response.json();
          console.log(data);
          setAssetList(data);
        } else {
          console.error('Error fetching asset details:', response.statusText);
        }
      } catch (error) {
        console.error('Error fetching asset details:', error.message);
      }
    };

    fetchAssetDetails();
  }, [ionAccessToken, ionAssetId]);
  const setupTiles = () => {
    tiles.fetchOptions.mode = 'cors';

    const dracoLoader = new DRACOLoader();
    dracoLoader.setDecoderPath('https://unpkg.com/three@0.153.0/examples/jsm/libs/draco/gltf/');

    const loader = new GLTFLoader(tiles.manager);
    loader.setDRACOLoader(dracoLoader);

    tiles.manager.addHandler(/\.gltf$/, loader);
    scene.add(tiles.group);
    
  };

  const reinstantiateTiles = () => {
    if (tiles) {
      scene.remove(tiles.group);
      tiles.dispose();
      tiles = null;
    }

    tiles = new CesiumIonTilesRenderer(params.ionAssetId, params.ionAccessToken);
    tiles.onLoadTileSet = () => {
      const sphere = new THREE.Sphere();
      tiles.getBoundingSphere(sphere);

      const position = sphere.center.clone();
      const distanceToEllipsoidCenter = position.length();

      const surfaceDirection = position.normalize();
      const up = new THREE.Vector3(0, 1, 0);
      const rotationToNorthPole = rotationBetweenDirections(surfaceDirection, up);

      tiles.group.quaternion.x = rotationToNorthPole.x;
      tiles.group.quaternion.y = rotationToNorthPole.y;
      tiles.group.quaternion.z = rotationToNorthPole.z;
      tiles.group.quaternion.w = rotationToNorthPole.w;

      tiles.group.position.y = -distanceToEllipsoidCenter;
    };

    setupTiles();
  };

  const rotationBetweenDirections = (dir1, dir2) => {
    const rotation = new THREE.Quaternion();
    const a = new THREE.Vector3().crossVectors(dir1, dir2);
    rotation.x = a.x;
    rotation.y = a.y;
    rotation.z = a.z;
    rotation.w = 1 + dir1.clone().dot(dir2);
    rotation.normalize();

    return rotation;
  };

  const init = () => {
    scene = new THREE.Scene();

    renderer = new THREE.WebGLRenderer({ antialias: true, canvas: canvasRef.current });
    renderer.setClearColor(0xfff000);
    renderer.domElement.tabIndex = 1;

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 4000);
    camera.position.set(0, 0, 5);
    

    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.screenSpacePanning = false;
    controls.minDistance = 1;
    controls.maxDistance = 2000;

    light = new THREE.PointLight(0xffff00, 1);
    camera.add(light);
    scene.add(camera);

    const dirLight = new THREE.DirectionalLight(0xffffff);
    dirLight.position.set(1, 2, 3);
    scene.add(dirLight);

    const ambLight = new THREE.AmbientLight(0xffffff, 0.2);
    scene.add(ambLight);

    offsetParent = new THREE.Group();
    scene.add(offsetParent);

    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();

    enableInteractions();

    reinstantiateTiles();

    onWindowResize();
    window.addEventListener('resize', onWindowResize, false);

    const gui = new GUI();
    gui.width = 300;

    const ionOptions = gui.addFolder('myasset');
    ionOptions.add(params, 'ionAssetId');
    ionOptions.add(params, 'ionAccessToken');
    ionOptions.add(params, 'reload');
    ionOptions.open();
  };

  const setHighlight = (color) => {
    if (selectedObject) {
      const hexColor = new THREE.Color(color).getHex();
      selectedObject.material.color.set(hexColor);
    }
  };

  const onMouseMove = (event) => {
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  };

  const onMouseClick = (event) => {
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(scene.children, true);

    if (intersects.length > 0) {
      const clickedObject = intersects[0].object;

      if (event.button === 0) {
        console.log('Left-click');
        if (selectedObject) {
          selectedObject.material.color.set(0xffffff);
        }

        selectedObject = clickedObject;
        selectedObject.material.color.set(highlightColor);
          // Log details of the previously selected mesh
          console.log("Previous Selected Mesh Details:", selectedObject);
      
         
      }
      if (event.button === 2) {
        console.log('Right-click');
        setContextMenuPosition({ x: event.clientX, y: event.clientY });

		raycaster.setFromCamera({ x: mouse.x, y: mouse.y + 0.1 }, camera);

		const intersectsAbove = raycaster.intersectObjects(scene.children, true);
	
		if (intersectsAbove.length > 0) {
		  selectedObject = intersectsAbove[0].object;
		} else {
		  setContextMenuPosition({ x: 0, y: 0 });
		  selectedObject = null;
		}
      }
    } else {
      if (selectedObject && event.button === 0) {
        console.log('Clicked outside of any object');
        selectedObject.material.color.set(0xffffff);
        selectedObject = null;
      }
    }
  };

  const enableInteractions = () => {
    renderer.domElement.addEventListener('mousemove', onMouseMove);
    renderer.domElement.addEventListener('click', onMouseClick);
    renderer.domElement.addEventListener('contextmenu', handleContextMenu);
    renderer.domElement.addEventListener('click', handleClickOutsideContextMenu);
  };

  const handleContextMenu = (event) => {
   
	if (selectedObject) {
		setContextMenuPosition({ x: event.clientX, y: event.clientY });
    
	  }
  };

  const handleContextMenuColorChange = (color) => {

    setHighlightColor(color);

    if (selectedObject) {
      const hexColor = new THREE.Color(color).getHex();
      selectedObject.material.color.set(hexColor);
    }
  };

  const handleClickOutsideContextMenu = () => {
    if (contextMenuPosition.x !== 0 && contextMenuPosition.y !== 0) {
      setContextMenuPosition({ x: 0, y: 0 });
    }
  };


  const onWindowResize = () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
  };

  const animate = () => {
    requestAnimationFrame(animate);

    if (!tiles) return;

    tiles.setCamera(camera);
    tiles.setResolutionFromRenderer(camera, renderer);

    camera.updateMatrixWorld();
    tiles.update();

    renderer.render(scene, camera);

    if (controls) {
      controls.update();
    }
  };

  const cleanUp = () => {
    renderer.domElement.removeEventListener('mousemove', onMouseMove);
    renderer.domElement.removeEventListener('click', onMouseClick);
    renderer.domElement.removeEventListener('contextmenu', handleContextMenu);
    renderer.domElement.removeEventListener('click', handleClickOutsideContextMenu);
  };

  useEffect(() => {
    init();
    animate();

    return () => {
      cleanUp();
    };
  }, [highlightColor]);

  const renderContextMenu = () => {
    if (contextMenuPosition.x !== 0 && contextMenuPosition.y !== 0) {
      return (
        <div
          style={{
            position: 'absolute',
            top: contextMenuPosition.y,
            left: contextMenuPosition.x,
            background: '#fff',
            padding: '5px',
            boxShadow: '0px 0px 5px 0px rgba(0,0,0,0.75)',
            zIndex: 1000,
          }}
        >
           <label> Select Highlight Color: </label>
          <input
            type="color"
            value={highlightColor}
            onInput={(e) => handleContextMenuColorChange(e.target.value)}
          />            
        </div>
      );
    }
    return null;
  };
  
  return (
    <div>
      {renderContextMenu()}
      <canvas ref={canvasRef}></canvas>
    </div>
  );
}

export default NewComponent;



  const uploadAsset = async (e) => {
         e.preventDefault()
      if (!profile) {
        console.error('Please select a file.');
        return;
      }
  
      try {      
        const response = await axios.post(
          'https://api.cesium.com/v1/assets',
           {
            name: normalUserInputs.name,
            description: normalUserInputs.description,
            type: '3DTILES',
            options: {
                sourceType: '3D_MODEL', // Correct sourceType
               //  clampToTerrain: true,
               //  baseTerrainId: 1
            }
        },
        {
          headers: { Authorization: `Bearer ${ionAccessToken}` },
        }         
      );
   console.log(response);
  
        if (response.status === 200) {
          const uploadedAsset = response.data;
          console.log('Uploaded Asset:', uploadedAsset);
          setAssetId(uploadedAsset.id);
  
          // Step 2: Upload the glTF file to ion using response.uploadLocation
          console.log('Asset created. Uploading PL-202051_HO.fbx');
          const uploadLocation = response.data.uploadLocation;
          console.log(uploadLocation)
  
          // Assuming you have the necessary AWS SDK and request libraries imported
          // Make sure to replace 'input' with the actual path to your file
          // Also, replace 'accessToken' with the appropriate variable in your context
          // or state that stores the Ion access token.
          const s3 = new AWS.S3({
            apiVersion: '2006-03-01',
            region: 'us-east-1',
            signatureVersion: 'v4',
            endpoint: uploadLocation.endpoint,
            credentials: new AWS.Credentials(
              uploadLocation.accessKey,
              uploadLocation.secretAccessKey,
              uploadLocation.sessionToken
            ),
          });
          console.log(s3)
          const input = profile
          console.log(input)
  
          await s3.upload({
            Body: input, // Replace 'input' with the actual path to your file
            Bucket: uploadLocation.bucket,
            Key: `${uploadLocation.prefix}Support1.zip`,
          }).on('httpUploadProgress', function (progress) {
            console.log(`Upload: ${((progress.loaded / progress.total) * 100).toFixed(2)}%`);
          }).promise();
  
          // Step 3: Tell ion we are done uploading files.
          const onComplete = response.data.onComplete;
          console.log("entering oncomplete");
          await axios({
            url: onComplete.url,
            method: onComplete.method,
            headers: { Authorization: `Bearer ${ionAccessToken}` },
            json: true,
            data: onComplete.fields,
          });
          console.log("outside oncomplete");
        } else {
          console.error('Error uploading asset:', response.data.statusText);
        }
        const waitUntilReady=async(response) =>{
          try{
            const assetId = response.data.assetMetadata.id;
            console.log(assetId);

            // Issue a GET request for the metadata
            const assetMetadata = await axios.get(
               `https://api.cesium.com/v1/assets/${assetId}`,

                {headers: { Authorization: `Bearer ${ionAccessToken}` }},
            );
            console.log(assetMetadata)

            const status = assetMetadata.data.status;
            console.log(status)
            if (status === 'COMPLETE') {
                console.log('Asset tiled successfully');
                console.log(`View in ion: https://cesium.com/ion/assets/${assetMetadata.data.id}`);
            } else if (status === 'DATA_ERROR') {
                console.log('ion detected a problem with the uploaded data.');
            } else if (status === 'ERROR') {
                console.log('An unknown tiling error occurred, please contact support@cesium.com.');
            } else {
                if (status === 'NOT_STARTED') {
                    console.log('Tiling pipeline initializing.');
                } else { // IN_PROGRESS
                    console.log(`Asset is ${assetMetadata.data.percentComplete}% complete.`);
                }

                 // Not done yet, check again in 10 seconds
                  setTimeout(() => waitUntilReady(response), 10000);
            }

        }catch(error){
            console.error('Error in waitUntilReady:', error.message);
        }
  
      }
      waitUntilReady(response);
      
    
  }
  catch (error) {
    console.log(error.message);
  } 
   };


  //  --------------------------------------------
  import React, { useState, useEffect, useRef } from 'react';
import { DebugTilesRenderer as TilesRenderer, NONE } from '3d-tiles-renderer';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
import { GUI } from 'three/examples/jsm/libs/lil-gui.module.min.js';
import { CesiumIonTilesRenderer } from '3d-tiles-renderer';
import { CSS2DRenderer } from 'three/examples/jsm/renderers/CSS2DRenderer';
import Label from './Label';
import { Box3 } from 'three';
import { CSS2DObject } from 'three/examples/jsm/renderers/CSS2DRenderer';


function NewComponent() {
  let camera, controls, scene, renderer, tiles, offsetParent, raycaster, mouse, css2dRenderer,cameraHelper;
  let selectedObject = null;

  const canvasRef = useRef(null);
  const [highlightColor, setHighlightColor] = useState('#ff0000');
  const [contextMenuPosition, setContextMenuPosition] = useState({ x: 0, y: 0 });
  const [assetList, setAssetList] = useState([]);
  const [labels, setLabels] = useState([]);
   // Assuming offsetTable contains the coordinates from the offset table
  const offsetTable = [
    { objectname:"CD3-PSUP.fbx",meshname:"BOX_1_of_SUBSTRUCTURE_PSCD30001F1Plates",x: 0, y: 0, z: 0 }, // Example coordinates, replace with actual data
    { objectname:"CD3-PSUP.fbx",meshname:"BOX_1_of_SUBSTRUCTURE",x: 0, y: -0.44, z: -0.44 },
    { objectname:"CD3-PSUP.fbx",meshname:"BOX_1",x: 10.28, y: 0, z: 10 },
  ];

  
  const params = {
    'raycast': NONE,
    'ionAssetId': '2420609',
    'ionAccessToken': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIwZWU3MTJjNi00Njk1LTQxZDktYmE4OS1mY2I3NTIyYzVhZTgiLCJpZCI6MTg3NjI0LCJpYXQiOjE3MDQ1NjAzMzF9.5FAkHltPwh5gROFmAfIEalS68ob5Xnsjt7EMkNcyIjE',
    'reload': () => {
      reinstantiateTiles();
    }
  };
  const ionAssetId = '2420609';
  const ionAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIwZWU3MTJjNi00Njk1LTQxZDktYmE4OS1mY2I3NTIyYzVhZTgiLCJpZCI6MTg3NjI0LCJpYXQiOjE3MDQ1NjAzMzF9.5FAkHltPwh5gROFmAfIEalS68ob5Xnsjt7EMkNcyIjE';

  useEffect(() => {
    console.log(offsetTable)
    const fetchAssetDetails = async () => {
      try {
        const response = await fetch(`https://api.cesium.com/v1/assets`, {
          headers: {
            Authorization: `Bearer ${ionAccessToken}`,
          },
        });

        if (response.ok) {
          const data = await response.json();
          console.log(data);
          setAssetList(data);
        } else {
          console.error('Error fetching asset details:', response.statusText);
        }
      } catch (error) {
        console.error('Error fetching asset details:', error.message);
      }
    };

    fetchAssetDetails();
  }, [ionAccessToken, ionAssetId]);

  const setupTiles = () => {
    tiles.fetchOptions.mode = 'cors';

    const dracoLoader = new DRACOLoader();
    dracoLoader.setDecoderPath('https://unpkg.com/three@0.153.0/examples/jsm/libs/draco/gltf/');
    const loader = new GLTFLoader(tiles.manager);
    loader.setDRACOLoader(dracoLoader);
    tiles.manager.addHandler(/\.gltf$/, loader);
    scene.add(tiles.group);
  };

  const reinstantiateTiles = () => {
    if (tiles) {
      scene.remove(tiles.group);
      tiles.dispose();
      tiles = null;
    }

    tiles = new CesiumIonTilesRenderer(params.ionAssetId, params.ionAccessToken);
    tiles.onLoadTileSet = () => {
      const sphere = new THREE.Sphere();
      tiles.getBoundingSphere(sphere);

      const position = sphere.center.clone();
      const distanceToEllipsoidCenter = position.length();

      const surfaceDirection = position.normalize();
      const up = new THREE.Vector3(0, 1, 0);
      const rotationToNorthPole = rotationBetweenDirections(surfaceDirection, up);

      tiles.group.quaternion.x = rotationToNorthPole.x;
      tiles.group.quaternion.y = rotationToNorthPole.y;
      tiles.group.quaternion.z = rotationToNorthPole.z;
      tiles.group.quaternion.w = rotationToNorthPole.w;

      tiles.group.position.y = -distanceToEllipsoidCenter;
      setupTiles();
      // Create spheres based on the offset table data
  // createSpheres(offsetTable);
  createLabels();

    };
       setupTiles();
  };
  // const createSpheres = (offsetTable) => {
  //   offsetTable.forEach((offset) => {
  //     // // Create a sphere geometry
  //     // const geometry = new THREE.SphereGeometry(0.5, 32, 32);
  
  //     // // Create a material for the sphere
  //     // const material = new THREE.MeshBasicMaterial({ color: 0xffff00 });
  
  //     // // Create the mesh (sphere) using geometry and material
  //     // const sphere = new THREE.Mesh(geometry, material);
  
  //     // // Set the position of the sphere based on offset table coordinates
  //     // sphere.position.set(offset.x, offset.y, offset.z);
  
  //     // // Add the sphere to the scene
  //     // scene.add(sphere);
  //       // Create label for the sphere
  //       const label = document.createElement('div');
  //       label.className = 'label';
  //       label.textContent = offset.meshname; // Set label text to mesh name
  //       label.style.position = 'absolute';
  //       label.style.color = '#ffffff';
  //       label.style.top = '0';
  //       label.style.transform = 'translate(-50%, -50%)';
  //       css2dRenderer.domElement.appendChild(label);

  //       // Create CSS2D object for the label
  //       const labelObject = new CSS2DObject(label);
  //       labelObject.position.set(offset.x, offset.y, offset.z);
  //       scene.add(labelObject);
  //   });
  // };
  
  const createLabels = () => {
    offsetTable.forEach((labelInfo) => {
      const labelDiv = document.createElement('div');
      labelDiv.className = 'label';
      labelDiv.textContent = labelInfo.meshname;
      labelDiv.style.color = '#ffffff';

      const labelObject = new CSS2DObject(labelDiv);
      labelObject.position.set(labelInfo.x, labelInfo.y, labelInfo.z);

      scene.add(labelObject);
    });
  };


  const rotationBetweenDirections = (dir1, dir2) => {
    const rotation = new THREE.Quaternion();
    const a = new THREE.Vector3().crossVectors(dir1, dir2);
    rotation.x = a.x;
    rotation.y = a.y;
    rotation.z = a.z;
    rotation.w = 1 + dir1.clone().dot(dir2);
    rotation.normalize();

    return rotation;
  };

  const init = () => {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 4000);
    camera.position.set(0, 0, 5);
    renderer = new THREE.WebGLRenderer({ canvas: canvasRef.current });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0xff0000);
    document.body.appendChild(renderer.domElement)
    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.screenSpacePanning = false;
    controls.minDistance = 1;
    controls.maxDistance = 2000;

    const dirLight = new THREE.DirectionalLight(0xffffff);
    dirLight.position.set(1, 2, 3);
    scene.add(dirLight);

    const ambLight = new THREE.AmbientLight(0xffffff, 0.2);
    scene.add(ambLight);

    offsetParent = new THREE.Group();
    scene.add(offsetParent);

    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();

    enableInteractions();

    reinstantiateTiles();
    css2dRenderer = new CSS2DRenderer();
    css2dRenderer.setSize(window.innerWidth, window.innerHeight);
    css2dRenderer.domElement.style.position = 'absolute';
    css2dRenderer.domElement.style.top = 0;
    document.body.appendChild(css2dRenderer.domElement);

    onWindowResize();
    window.addEventListener('resize', onWindowResize, false);
    const gui = new GUI();
    gui.width = 300;

    const ionOptions = gui.addFolder('myasset');
    ionOptions.add(params, 'ionAssetId');
    ionOptions.add(params, 'ionAccessToken');
    ionOptions.add(params, 'reload');
    ionOptions.open();
   
  };

  const setHighlight = (color) => {
    if (selectedObject) {
      const hexColor = new THREE.Color(color).getHex();
      selectedObject.material.color.set(hexColor);
    }
  };

  const onMouseMove = (event) => {
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  };

  const onMouseClick = (event) => {
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(scene.children, true);

    if (intersects.length > 0) {
      const clickedObject = intersects[0].object;

      if (event.button === 0) {
        console.log('Left-click');
        if (selectedObject) {
          selectedObject.material.color.set(0xffffff);
        }

        selectedObject = clickedObject;
        selectedObject.material.color.set(highlightColor);
        

      // bounding box of clicked object
       // Calculate bounding box coordinates
       const boundingBox = new Box3().setFromObject(selectedObject);
       const center = boundingBox.getCenter(new THREE.Vector3());
       const size = boundingBox.getSize(new THREE.Vector3());
       const minCoordinates = boundingBox.min.clone();
       const maxCoordinates = boundingBox.max.clone();
      //  console.log("Bounding Box Min Coordinates:", minCoordinates);
      //  console.log("Bounding Box Max Coordinates:", maxCoordinates);
       console.log("Bounding Box center:", center);    
      }
     
    } else {
      if (selectedObject && event.button === 0) {
        console.log('Clicked outside of any object');
        selectedObject.material.color.set(0xffffff);
        selectedObject = null;
      }
    }
  };
 


  const enableInteractions = () => {
    renderer.domElement.addEventListener('mousemove', onMouseMove);
    renderer.domElement.addEventListener('click', onMouseClick);
    renderer.domElement.addEventListener('click', handleClickOutsideContextMenu);
  };



  const handleClickOutsideContextMenu = () => {
    if (contextMenuPosition.x !== 0 && contextMenuPosition.y !== 0) {
      setContextMenuPosition({ x: 0, y: 0 });
    }
  };

  const onWindowResize = () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
  };



  const animate = () => {
    requestAnimationFrame(animate);

    if (!tiles) return;

    tiles.setCamera(camera);
    tiles.setResolutionFromRenderer(camera, renderer);

    camera.updateMatrixWorld();
    tiles.update();
    if (renderer && scene && camera && css2dRenderer) {
 
      renderer.render(scene, camera);
      css2dRenderer.render(scene, camera);
    }
    if (controls) {
      controls.update();
    }
    
  };

  const cleanUp = () => {
    renderer.domElement.removeEventListener('mousemove', onMouseMove);
    renderer.domElement.removeEventListener('click', onMouseClick);
    renderer.domElement.removeEventListener('click', handleClickOutsideContextMenu);
  };

  useEffect(() => {
    init();

    animate();

    return () => {
      cleanUp();
    };
  }, [highlightColor]);

  

  return (
    <div style={{ position: 'relative' }}>
      <canvas ref={canvasRef}></canvas>
    </div>
  );
}

export default NewComponent;

